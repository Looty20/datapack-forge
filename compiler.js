/**
 * Compiles selected perks and their settings into a file map.
 * @param {Array} perks - All available perks
 * @param {Array} selectedIds - IDs of selected perks
 * @param {Object} userSettings - User-specified settings per perk
 * @returns {Object} File paths as keys and file contents as values
 */
export async function compileDatapack(perks, selectedIds, userSettings) {
  const files = {};

  for (const perk of perks) {
      if (!selectedIds.includes(perk.id) || !perk.files) continue;

      for (const file of perk.files) {
          let content = file.content;

          // Replace macros with actual values
          for (const setting of perk.settings || []) {
              const value = userSettings[perk.id]?.[setting.id] ?? setting.default;
              content = content.replaceAll(`[${setting.id}]`, value);
          }

          if (files[file.path]) {
              if (file.path.endsWith(".json")) {
                  // For JSON files, overwrite instead of appending
                  files[file.path] = content;
              } else {
                  // For other files (e.g., .mcfunction), append
                  files[file.path] += '\n' + content;
              }
          } else {
              files[file.path] = content;
          }

          if (file.path.endsWith("load.mcfunction") || file.path.endsWith("tick.mcfunction")) {
              const tag = file.path.endsWith("load.mcfunction") ? "load" : "tick";
              const tagPath = `data/minecraft/tags/function/${tag}.json`;

              const match = file.path.match(/^data\/([^/]+)\/function\/(.+)\.mcfunction$/);
              if (!match) {
                  console.warn(`Failed to match namespace:path for load/tick function: ${file.path}`);
                  continue;
              }

              const namespace = match[1];
              const funcPath = match[2];
              const funcName = `${namespace}:${funcPath}`;

              if (!files[tagPath]) {
                  files[tagPath] = JSON.stringify({ values: [funcName] }, null, 2);
              } else {
                  const existing = JSON.parse(files[tagPath]);
                  if (!existing.values.includes(funcName)) {
                      existing.values.push(funcName);
                      files[tagPath] = JSON.stringify(existing, null, 2);
                  }
              }
          }
      }
  }

  // Add pack.mcmeta (pack_format 71 = Minecraft 1.20.5+)
  files["pack.mcmeta"] = JSON.stringify({
      pack: {
          pack_format: 71,
          description: "Generated by Datapack Forge"
      }
  }, null, 2);

  // Add pack.png from the same root directory
  files["pack.png"] = await fetch("pack.png")
      .then(res => res.blob())
      .catch(() => new Blob()); // fallback if missing

  return files;
}

/**
* Generates and downloads the datapack as a ZIP archive.
* @param {Object} files - Output from compileDatapack
* @param {string} zipName - Name for the downloaded ZIP
*/
export async function exportZip(files, zipName = "datapack.zip") {
  const zip = new JSZip(); // Use global JSZip from CDN

  for (const path in files) {
      zip.file(path, files[path]);
  }

  const blob = await zip.generateAsync({ type: "blob" });
  const link = document.createElement("a");
  link.href = URL.createObjectURL(blob);
  link.download = zipName;
  link.click();
}
